---
description: 天下大势，分久必合，合久必分
---

# 组件结构

我们在谈组件化的时候，很多时候我们会谈到“拆库”。以 iOS 为例，我们会使用使用 CocoaPods 拆为一个个的 Pod，然后再通过 Podfile 组装起来。而组件化中的拆库，实际上在谈一个事情“隔离”。

1. 如何划分不同物料的边界，最好这些边界是清晰的。
2. 如何做到业务和业务之间的隔离
3. 如何让业务自己独立的发版和迭代节奏
4. 如果进行有效的分层，让业务开发能够不用关注底层的变动。

所以这里面会牵扯到两个问题：

* 组件内部的结构是什么样子的
* 组件之间的结构是什么样子的

接下来我们将会分两部分阐述这两种结构。组件内部结构将会从前面讲到到组件定义中对齐下来。虽然，看起来我们需要首先说清楚一个组件长什么样子，然后再去讲一群组件在一起是什么样子。 但是，往往在做组件化这个事情的时候，我们首先会关注到的是组件间的结构。 所以我们会优先讨论组件间结构。 是

## 组件间结构

最开始的时候， 我们的工程是“单体工程”。一个工程文件， 然后加上一堆的代码。 大概也就是我们的工程了。但是，当代码规模变大后。就会发现， 单体工程的可维护性会逐渐变差。 好一点的，可能会拆一下目录。这里说的目录还是 IDE 里面的目录结构。拿 iOS 来说 XCode 里面的目录结构，与文件系统中的目录结构是不一致的。然后，就会引发一个非常尴尬的问题，基本上代码是无法 CodeReview 的。 因为无法通过 CodeReview 单子中的目录结构，知道这个代码是干嘛的。这是维护性降低的一个例子。&#x20;

于是我们就开始“拆库”。那按照什么规则拆分呢？简单来说：纵向分层，横向正交。&#x20;

组件间的结构，其实是一个非常复杂的结构。我们可以先看一个复杂应用实际的组件之间的依赖情况：

![某复杂应用组件依赖](../../.gitbook/assets/image.png)

形如这种组件之间的依赖关系组成的拓扑结构，我们可以理解成是组件之间的物理结构。但是，很明显，这个图的可阅读性已经是非常差。1500+的组件，其关系错综复杂。这个结构其实在我们进行**架构设计**的时候，能够给我们提供的信息是有限的。他主要是在进行组件治理阶段，我们关注具体的组件A与组件B之间的关系的时候，会有作用。于是我们为了能够方便我们理解组件间结构关系，我们一般会创建一种逻辑结构。在工程实践中，我们称这种弄结构为**分层架构**。

所谓纵向分层，即是我们通过分层架构，对我们工程域中的组件进行归类。 一般我们的分层依据是与业务的亲和度。换句话说，就是离我们真实业务的距离。&#x20;

们在讨论组件间的结构的时候，一方面是在讨论这种物理结构，另外一方面我们也在讨论组件的逻辑结构。而在更多的时候时候，我们讨论的是分层架构这种逻辑结构。因为一个层次清晰的架构图，更能够辅助我们来设计/理解我们的系统。接下来，我们先花点时间集中讨论一下如何在组件化的场景下实施分层架构。对于组件的物理结构部分，会放在组件治理话题下展开讨论。

### 纵向分层

分层是一个非常自然的选择。当组件数量增多的时候，我们会习惯将具有相同特性的组件进行归类。

### 横向正交



## 组件内部结构

### 组件组成要素

### 目录结构



##
