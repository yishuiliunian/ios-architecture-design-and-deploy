# 组件化

## 组件与组件化定义

组件，主要是指一簇因可以完成一定的功能聚合在一起的代码、资源、配置文件等组成的一个实体。组件物理形态上的隔离，一般我们会使用目录结构、仓库等方式来完成隔离。而进一步的去看，组成组件的各种东西，我们可以统称为“物料”。这个是一个非常重要的概念，在后续讨论组件化的时候，我们都会使用这个概念。这个概念借鉴自，传统的工厂制造设计。在 Wiki 上物料的定义是：指在产品[制造](https://zh.wikipedia.org/wiki/%E8%A3%BD%E9%80%A0)过程中，列入[生产计划](https://zh.wikipedia.org/w/index.php?title=%E7%94%9F%E4%BA%A7%E8%AE%A1%E5%88%92\&action=edit\&redlink=1)的一切**物**的总称。按照制造的过程来区分，可包括[原料](https://zh.wikipedia.org/wiki/%E5%8E%9F%E6%96%99)、[半成品](https://zh.wikipedia.org/wiki/%E5%8D%8A%E6%88%90%E5%93%81)、[成品](https://zh.wikipedia.org/wiki/%E6%88%90%E5%93%81)等等。而在这里，我们会发现，我们在客户端领域所谓的组件即是把相对原始的低吗、资源、配置文件等物料，组合成了一种新的物料形态，即组件。

对应的我们或说道组件化。首先说明，组件化首先是个动词。意味着我们要以组件这种物料形式，对我们原始物料进行物理隔离，并以之来组织我们的工程结构。其中最核心的问题是依赖管理，文件管理、资源管理问题。在谈到依赖管理的时候，一般会讨论包管理系统，比如我们现在使用的Pod、Maven、Pip、Npm等包管理工具解决的主要是组件化的问题。（PS，不要参考前端组件化，前端组件化，和咱们说的组件化完成不是一个概念，他只是说把一个功能单元Package一下）。在谈到文件管理的时候，一般会与 git 、svn 这种版本管理工具扯到一起，同时我们也会去讨论目录结构。

我们引入了一个概念"物料“，之所以引入这个概念。是因为在后续处理组件化的过程中，我们将会产生大量的”半成品“，或者说过程产物。这些东西，统称为物料。例如在 iOS 领域，我们经常会处理一个问题：二进制缓存。我们希望通过缓存构建过程产物，以在下次构建过程中能够复用，从而极大的节省整体的构建时间。 而这种关键过程产物，就是一种物料。类似这种物料，在整个工程预中，还有大量存在。例如文档、配置文件..... 于是这里将会引申出”组件化”对物料的管理，其实不限于我们存在仓库中的东西，还将会延展到我们整个工程域中产生很多类似“二进制构建过程产物”的物料。

定义物料例如组件，不是我们的目的。也就是说，我们一般所谓的“拆库”，把物料通过组件的形式进行隔离起来，并不是“组件化”的终点；而是起点。最终我们还是要将这些物料，组合起来来组成我们最终交付的“产品”。同样，在组件化这个命题里面，我们扔需要思考并设计这个组装的过程。以 iOS 的实现为例，在后面的章节中，我们将会介绍一种 Application Specification 的技术。通过 DSL 的方式，定义这个组装的过程，并使之能够标准化。记录组装过程的这些“配置文件”，同样也是一种物料。之前有很多团队，习惯性称之为“壳工程”。

既然我们定义了组件和物料，也自然会衍生出一个问题。如何管理这些物料，准确的讲是如何版本化管理这些物料。在一般的工程域中，我们已经习惯了使用类似 Git、SVN 这样的版本管理软件来进行管理。以 Git 为例吧，在物料管理上其所定义的版本方式会存在一定的缺陷。 具体说，就是版本只是标记，而无任何含义。例如我们拿一个 Commit SHA 来看 `d336dafa3666771507a76fb49d12a4860494d5aa`除了能够看出这是一个字符串，可能看不出其他的任何含义。相对而言， 这里存在一个更好的版本定义方式，也是在依赖关系系统中我们常用：[语义化版本](https://semver.org)。例如：1.1.0-alpha.0、1.1.0、1.1....根据语义化版本的定义，我们能够非常清晰的的明白，当前这个版本的含义。



我们做到这些之后，能够给整体的业务提供非常好的扩展能力。而这些是基于“组件”这种结构之上建设起来的。
